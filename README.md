#Этап 4: Функциональность на «React» и JS

Для начала локально создайте ветку. Назовите её level-3.
На этом этапе вам нужно:

реализовать обязательную функциональность, о которой мы расскажем дальше;
- сделать асинхронные GET- и POST-запросы к API;
- написать все запросы к нашему и стороннему API;
- защитить роуты /saved-movies, /profile и /movies авторизацией;
- для хранения данных о пользователе использовать глобальную стейт-переменную currentUser, созданную с помощью 
createContext;
- в компонент App внедрить контекст через CurrentUserContext.Provider;
- JWT-токен хранить в localStorage или в куке;
- сделать так, чтобы ошибка от API была обработана и пользователь видел сообщение об ошибке;
- настроить прелоадер так, чтобы он крутился, пока от сервера идёт ответ;
- кликом по карточке переводить на ютюб-трейлер фильма.

#Работа с BeatfilmMoviesApi

#Блок поиска по фильмам

После сабмита формы поиска производится валидация. Если в поле не введён текст, выводится ошибка «Нужно ввести 
ключевое слово». Если слово введено, то осуществляется запрос к API. Сервис, к которому нужно обратиться — 
https://api.nomoreparties.co/beatfilm-movies. Вам не нужно настраивать параметры запроса — получите все данные с 
сервиса, а фильтровать их вы уже будете на клиентской части.
После получения данных от сервера нужно отобразить их в блоке результатов. О нём далее.

О реализации запросов

Для работы с нашим и сторонним сервисом в директории utils/ создайте два файла:
- MainApi.js,
- MoviesApi.js.

Первый файл будет содержать описание запросов к нашему Api. Второй — к сервису beatfilm-movies. Напишите этот код на нативном JS, применяя fetch. Вы можете использовать как обычные функции с импортом в нужные компоненты, так и классовую структуру.
Блок результатов

Блок результатов появляется только после обработки запроса. Если пользователь ещё ничего не искал, блока с карточками на 
странице нет. Как только запрос сделан, данные передаются в стейт-переменную и блок появляется. Для отрисовки данных 
воспользуйтесь хуком. До получения данных блок содержит прелоадер. Если ничего не найдено, на месте прелоадера появляется 
надпись «Ничего не найдено». Если в процессе получения и обработки данных происходит ошибка, в окне результатов выводится 
надпись: «Во время запроса произошла ошибка. Возможно, проблема с соединением или сервер недоступен. Подождите немного и 
попробуйте ещё раз». Когда данные получены, в блоке результатов исчезает прелоадер и появляются карточки фильмов. Их следует 
расположить в линию. Если сжимать окно браузера, карточки переносятся на следующую строку. Если карточек больше, чем требуется 
для отображения 4 рядов, то под ними появляется кнопка «Ещё». По нажатию отрисовываются ещё карточки, а кнопка сдвигается ниже, 
чтобы оказаться под блоком с карточками. Обратите внимание, что количество карточек, которые отображаются на странице, зависит
от ширины экрана устройства.
- Ширина 1280px — 4 ряда карточек. Кнопка «Ещё» загружает дополнительный ряд карточек.
- Ширина 768px — 4 ряда карточек. Кнопка «Ещё» загружает дополнительный ряд карточек.
- Ширина от 320px до 480px — 5 карточек по 1 в ряд. Кнопка «Ещё» загружает по 2 карточки.

В ряду отображайте столько карточек, сколько отображается в вашем макете на соответствующей ширине экрана.
Подумайте, как реализовать такое поведение и какими JavaScript возможностями можно воспользоваться для создания зависимости 
между шириной экрана устройства и количеством отображаемых и подгружаемых карточек. Проверяйте ширину устройства при 
монтировании компонента результатов. Также пользователь может изменять ширину экрана своего устройства. Например, переводя 
телефон из портретной ориентации в альбомную и наоборот. Это событие можно отслеживать с помощью слушателя “resize”. Чтобы 
колбэк-функция слушателя не срабатывала слишком часто, например при изменении ширины экрана в отладчике, мы рекомендуем 
установить setTimeout на вызов этой функции внутри слушателя “resize”. Когда все карточки отрисованы, кнопка «Ещё» должна 
пропасть. Восстановление результатов предыдущего поиска на странице всех фильмов

Помимо отображения найденных фильмов, нужно сделать так, чтобы результаты уже выполненного запроса не пропадали, а снова 
отображались пользователю, если он перезагрузил страницу или даже закрыл вкладку, но потом вернулся на сайт. Для этого после 
поиска фильмов сохраните в localStorage текст запроса, состояние переключателя короткометражек и найденные 
фильмы. Если пользователь повторно переходит на страницу фильмов, то при монтировании компонента доставайте данные из 
локального хранилища. В соответствии с этими данными устанавливайте текст в строке поиска, правильное состояние переключателя 
короткометражек и отображайте на странице ранее найденные фильмы, взятые из хранилища. Обратите внимание, кнопка «Ещё» при 
отображении ранее найденных фильмов должна продолжать работать корректно. Выстройте работу с локальным хранилищем и 
стейт-переменной в правильном порядке. При обработке данных хранилища предусмотрите ситуацию, при которой данных в нём может и 
не быть. Например, по какой-то причине хранилище было очищено или зашёл новый пользователь, который ещё ни разу не искал 
фильмы. При отсутствии данных в хранилище приложение не должно падать с ошибкой. Также не забудьте при выходе пользователя с 
сайта вызывать очистку хранилища, иначе другой пользователь зайдёт на сайт и увидит запрос предыдущего пользователя, что не 
всегда допустимо. Сохранять данные поиска на странице «Сохранённые фильмы» в localStorage не требуется. При переходе 
пользователя на страницу сохранённых фильмов ему должны быть отображены все его фильмы.

# Карточка

Такие данные карточки мы получаем в ответе BeatfilmMoviesApi:
название фильма на русском языке находится в свойстве nameRU;
изображение — в image.url;
Изображения приходят с сервера с относительным, а не абсолютным URL. Не забудьте добавить к ним URL сервера — 
https://api.nomoreparties.co/. ссылка на трейлер — в trailerLink; длительность фильма рассчитывается на основе поля duration 
и должна отображаться в часах и минутах. Рядом с заголовком есть иконка лайка. Если пользователь лайкнул фильм — иконка 
отображается в активном состоянии с заливкой. При повторном нажатии — иконка остаётся без заливки. Активное и обычное состояние
иконки «Лайк» Клик по иконке без заливки должен отправлять запрос к /movies нашего API на сохранение фильма. Клик по иконке 
с заливкой — запрос на удаление. Добавленный фильм будет отображаться на странице сохранённых фильмов. При удалении фильм отображаться 
не будет. При сохранении и удалении фильма заливка иконки должна изменяться.

# Авторизация и регистрация, редактирование профиля

Для реализации механизма регистрации и авторизации у вас уже есть компоненты страниц Register и Login. Теперь нужно подготовить все 
необходимые стейт-переменные. Разберём подробнее работу каждой страницы.

# Страница регистрации

При нажатии на кнопку «Регистрация» в шапке сайта на главной странице происходит переход на страницу регистрации по маршруту /signup.

# Страница регистрации пользователя

Перед отправкой формы на фронтенде нужно проверить, что:
- все поля обязательные;
- поле email соответствует шаблону электронной почты;
- поле name содержит только латиницу, кириллицу, пробел или дефис.

Для валидации электронной почты можно использовать сторонние библиотеки. Если одно из полей не заполнено или не прошло валидацию, кнопка
«Зарегистрироваться» должна быть неактивна. Неактивная кнопка имеет другой цвет, и по ней невозможно кликнуть. Валидация должна 
происходить моментально, то есть при вводе нового символа в поле. Ошибки валидации выводите под полями ввода. Вы уже реализовывали 
подобный механизм валидации, но делали это на нативном JS. Теперь вам предстоит самостоятельно написать решение для валидации, но на 
«Реакте». Для этого можно создать отдельный компонент. Если нужно, посмотрите пример такого компонента и почитайте про хук useCallback.
Когда форма заполнена корректно, кнопка «Зарегистрироваться» становится активной. Клик по ней должен отправлять запрос на роут /signup 
нашего API. Если в ответе на этот запрос сервер возвращает ошибку, сообщение о ней должно располагаться над кнопкой «Зарегистрироваться».
Если ответ на запрос успешен, пользователь сразу авторизуется и будет перенаправлен на страницу «Фильмы».

# Страница логина

При нажатии на кнопку «Войти» в шапке сайта на главной странице происходит переход на страницу авторизации по маршруту /signin.

# Страница «Авторизация»

Форма входа тоже должна валидироваться на фронтенде:
- поля email и пароль обязательны,
- поле email должно соответствовать шаблону почты.
Всё остальное нужно настроить как в форме регистрации: моментальную механику валидации и показ ошибок в интерфейсе.
Если форма заполнена корректно, кнопка «Войти» становится активной. Клик по ней отправляет запрос на роут /signin. Если логин и 
- пароль правильные, сервер возвращает клиенту JWT. При этом токен должен сохраняться в localStorage или куку, а данные о 
- пользователе — в глобальную стейт-переменную currentUser. После этого происходит редирект на страницу «Фильмы».

# Страница редактирования профиля

У авторизованного пользователя в шапке сайта отображается кнопка «Аккаунт». При клике происходит переход на страницу редактирования 
профиля:

# Страница «Аккаунт»

На ней пользователь может изменить свои данные. Валидация происходит так же, как и на предыдущих страницах. Если данные введены 
корректно и отличаются от изначальных — кнопка «Редактировать» станет активна и пользователь сможет кликнуть по ней. Пользователя 
нужно уведомить о результате запроса к серверу. При клике на кнопку «Выйти из аккаунта» происходит редирект на главную страницу и 
удаление JWT из локального хранилища или куки. Чтобы войти на сайт заново, пользователю потребуется повторно авторизоваться.
Шапка сайта имеет разные пункты в меню в зависимости от того, авторизован ли пользователь. Поговорим об этом дальше.
Авторизованные и неавторизованные состояния. Сохранённые фильмы

# Шапка сайта

У шапки есть два состояния:
- Если пользователь не вошёл в систему и находится на главной странице, в шапке должны быть кнопки «Регистрация» и «Войти»:
Неавторизованное состояние шапки
- Если пользователь залогинился, в шапке сайта отображаются кнопки «Фильмы», «Сохранённые фильмы» и «Аккаунт»:
Авторизованное состояние шапки
- 
На главной странице шапка должна изменять своё состояние в зависимости от того, авторизован пользователь или нет.

# Страница с сохранёнными фильмами

В шапке сайта есть кнопка «Сохранённые фильмы». Она ведёт на отдельную страницу.
Сверху, под шапкой, отображается форма поиска, аналогичная форме на главной странице. Но между собой эти формы не должны быть связаны. 
То есть параметры фильтров со страницы всех фильмов не должны применяться при переходе к странице сохранённых фильмов.
При вводе данных в эту форму и её отправке — запрос к серверу не отправляется. Поиск происходит по фильмам, которые пользователь 
сохранил. Их вы уже получили при монтировании компонента этой страницы и выполнении соответствующего запроса к роуту /movies вашего API.
Внизу страницы «Сохранённые фильмы» располагаются карточки. Кнопки «Ещё» в этом блоке нет. Принцип отрисовки карточек на страницу 
такой же, как и на главной странице. А внешне каждая карточка похожа на результаты поиска фильмов, но есть одно отличие: рядом с 
заголовком расположена иконка удаления карточки. Клик по ней удаляет карточку из сохранённых, отправляя запрос на /movies/movieID 
нашего API. Если пользователь возвращается на страницу «Фильмы», то уже сохранённые им фильмы в блоке результатов должны иметь 
активную иконку лайка. Клик по ней на этой странице также удаляет фильм из сохранённых. Чтобы получить данные о сохранённых карточках, 
отправляйте GET-запрос к /movies нашего API. Если неавторизованный пользователь по прямой ссылке попытается попасть на страницу
«Сохранённые фильмы», «Фильмы», «Аккаунт» — должен произойти редирект на главную страницу. Для этого используйте HOC-компонент 
ProtectedRoute.

# Фильтрация данных на стороне клиента

При запросе к серверу за фильмами на странице «Фильмы» вы получаете сразу все данные и сохраняете их. При этом вам потребуется 
отсортировать результат по тексту запроса, который ввёл пользователь, и чекбоксу для короткометражных фильмов:

- При фильтрации по тексту запроса нужно проверять, есть ли введенные слова в названиях фильма на русском и английском — поля 
nameRU и nameEN. При этом на поиск не должен влиять регистр символов.
- Короткометражки фильтруются по длительности фильма — до 40 минут включительно. Если чекбокс короткометражек не отмечен, в результатах 
отображаются все фильмы, которые подходят под введённый запрос, в том числе и короткометражки. Если чекбокс отмечен, в результатах 
- запроса отображаются только короткометражные фильмы.

Если карточки уже были отображены на странице в блоке результатов, то клик по чекбоксу «Короткометражки» должен приводить к новой 
фильтрации всех фильмов с учётом нового состояния чекбокса и введённого текста запроса в форме поиска.
Для фильтрации данных и отображения нужных фильмов вы можете создать набор утилитарных функций или отдельный компонент. Мы не 
рекомендуем хранить эту логику непосредственно в компоненте MoviesCardList или схожих компонентах. Поиск на странице «Сохранённые 
фильмы» аналогичен поиску на главной, но данные у вас будут ещё до поиска — при запросе к вашему API на роут /movies для получения 
сохранённых фильмов.

# Заключение

Это описание основной функциональности проекта, которую нужно реализовать. Мы не углублялись в детали реализации — это вам предстоит 
продумать самостоятельно. Создавайте новые компоненты, если они потребуются. Добавляйте все необходимые стейт-переменные в проекте 
или их поднятие. Используйте хуки там, где нужно. Частично в этом могут помочь критерии оценки.

# Когда всё готово

Так как после этого этапа диплом будет готов, мы попросим вас сдавать эту часть работы архивом. Для этого:
В Readme.md добавьте:
Ссылку на пул реквест, открытый из ветки level-3 в main. Прикладывайте ссылку именно на пул реквест, а не на репозиторий, чтобы 
ревьюер мог оставить комментарии.
Ссылку на задеплоенный на сервере проект. Не забудьте загрузить на сервер последнюю версию проекта и обновлять при внесении правок.
Проект по приведённой ссылке должен работать корректно.

# Проверьте работу по чеклисту.

В аккаунте «Гитхаба» выберите ветку, в которой ведёте разработку — level-3.
Нажмите на кнопку “Code” и выберите “Download ZIP”.
💡 ВАЖНО. Если размер архива больше 10 МБ, сообщите об этом куратору.
Отправьте загруженный архив с кодом через эту форму:
Окно отправки архива дипломной работы
Не забудьте обновить архив перед каждой проверкой, если код в архиве и репозитории будет отличаться, работа будет отклонена от проверки.
Как только работа будет зачтена, нажмите кнопку “Merge”, чтобы применить изменения из ветки level-3 в main.
Вы проделали огромную работу, и это заключительный этап защиты диплома. Это ваше последнее ревью в Практикуме, но не последнее 
код-ревью в жизни.

# Чеклист

Обязательно проверьте работу по чеклисту.
Критерии оценки дипломной работы: https://code.s3.yandex.net/web-developer/static/new-program/web-diploma-criteria-2.0/checklist_react_diplom.pdf

Сборка проекта:
- npm i
- npm run build
- npm run start

Ссылка на макет: https://www.figma.com/file/6FMWkB94wE7KTkcCgUXtnC/light-1?type=design&node-id=891-3857&mode=design&t=SAUTEJ4fgoT4Jaf7-0

Макет: dark-2

IP: 130.193.36.139

Backend: api.lindasux.nomoredomainsicu.ru

Frontend: lindasux.nomoredomainsicu.ru
